## PLC逻辑生成 - 内嵌领域专用语言(half)

### 想法来源

使用`CX-Programmer`来编写PLC(Programmable Logic Controller)的代码时, 有2种编写模式

* **梯形图** -- 图形化可视效果好但是编写效率低
* **助记符** -- 编写效率高但是可读性差

个人的编程习惯是使用**助记符**来编写PLC的代码, 但是在写代码的过程中遇到了很多困难, 比如

1. 很难知道自己之前写的代码是做什么的, 即**逻辑表达不清晰** -- 这一点可以通过使用梯形图查看进行缓解
2. **无法记住相应的寄存器**是做什么的, 比如用输入`0`来代表停止运行, 在后边的逻辑编写中可以想起我应该有一个寄存器是用来代表停止运行这件事情, 但是想不起对应的应该是哪个数字, 特别是有很多寄存器都有其相对应的数字的情况下 -- 如果能用单词, 比如`run`来代表这个数字, 即**使用变量**这个概念, 那将带来极大的方便, 当然`CX-Programmer`中也能使用字母来代表数字, 但是每次使用都比较麻烦
3. **修改复杂, 代码量大**, 写程序时需要管理的细节多, 编程复杂度高, 比如想表达`C`等于`A`异或`B`, 用基础的`LD, OR, AND`写出来很复杂, 即使需要的信息在形式上只有`C = A ^ B`
4. **加注释困难**, 在梯形图上的注释看起来很直观, 但是在用`CX-Programmer`的助记符时, 几乎无法加入注释, 这无疑对可读性有比较大的影响

基于以上几点, 以及在当前需要完成的实验中, 逻辑表达式大量存在的前提下, 我尝试着写一个小工具来辅助自己编写PLC代码, 主要是为了减少代码编写量, 以及增加代码的可读性, 以及提供良好的抽象. 联想到之前有了解和听过的知识: **C++运算符重载**和**表达式树**, 感觉貌似可行, 说不定可以实现, 于是开始构思和code.

### 实现 - step by step

针对于学校PLC实验的环境:

* 硬件 -- `CPM2*`
* 软件 -- `CX-Programmer`

----------------------------

#### 对助记符的抽象

对于第一步的抽象针对下边这些指令, 由于是对于**逻辑表达式**的抽象, 所以只针对单个bit的运算, 比如输入端口`0,1,2`, 输出端口`1001,1002,1003`等单个bit的寄存器, 这里的抽象不适用于`DM`等由多个bit构成的寄存器.

| LD        | OUT        | AND        | OR        | ORLD      |
| --------- | ---------- | ---------- | --------- | --------- |
| **LDNOT** | **OUTNOT** | **ANDNOT** | **ORNOT** | **ANDLD** |

在PLC中, 如果想让输入`0`和输入`1`异或后输出到`1002`中, 

需要写这样的代码

```haskell
LD 0
ANDNOT 1
LDNOT 0
ANDNOT 1
ORLD
OUT 1002
```

这5行代码中, 描述的信息是`1002 = !0 * 1 + 0 * !1`, 注意, 这里使用`*, +, !`来分别代表与, 或, 非. 如果在写代码的时候, 可以直接写`1002 = !0 * 1 + 0 * !1`而不是上边的5行代码, 在写逻辑表达式的时候效率会提高不少.

要用C++来编写这类代码, 第一步可以做什么呢? 我的想法是先实现上述表格中10条助记符的功能, 想把C++写成PLC是不可能的, 这辈子都不可能的, 也就只能`cout`呀这样子来产生PLC代码. 具体的一个例子是

```c++
void ld(int number)
{
    cout << "LD " << number << endl;
}
```

当想在PLC助记符中输入`LD 7`时, 我就可以在C++中调用`ld`这个函数, 具体是语句`ld(7)`, 然后当C++的程序运行后, 就会产生输出`LD 7`, 这样, 一个C++函数就和一行PLC助记符对应上了.

如法炮制, 对于PLC助记符`ANDNOT`, 可以写为一个C++函数

```c++
void andnot(int number)
{
    cout << "ANDNOT " << number << endl;
}
```

当在C++中调用函数`andnot(3000)`时, 会生成PLC助记符`ANDNOT 3000`.

于是对于表格中的那10条助记符, 都可以编写出一个C++的函数与其对应, 当C++程序运行完毕后, 产生相应的PLC助记符.



以下为过去内容待更新

--------------------------

### 具体使用方法

需要声明PLC表达式, 然后用PLC表达式进行运算.

* `*`代表`and`
* `+`代表`or`
* `!`代表取反
* `>>`代表将左边表达式值输出到右边

具体代码如下

```c++
#include<iostream>
#include "PLC.h" // 包含PLC.h头文件, 放在程序相同目录下
using namespace std;

// 创建PLC表达式
PLCEXP a = 0; 
PLCEXP b = 1;
PLCEXP c = 1002;

int main()
{
    // 写逻辑运算的表达式
    a * !b + !a * b >> c; // 将 a * !b + !a * b 的结果输出到 c中
    return 0;
}
```

#### 效果

##### 生成的代码

```haskell
LD 0
LDNOT 1
ANDLD
LDNOT 0
LD 1
ANDLD
ORLD
OUT 1002
```

##### 梯形图

![](xor(a,b).PNG)

### 更复杂的例子

#### 不带TIM

实现`!(A+B * !D+C * !D)`输出到`E`.

我们知道`!(A+B * !D+C * !D) = !A * !(B * !D) * !(C * !D) = !A * (!B + D) * (!C + D) `

```c++
#include<iostream>
#include "PLC.h" // 包含PLC.h头文件, 放在程序相同目录下
using namespace std;

// 创建PLC表达式
PLCEXP A = 0;
PLCEXP B = 1;
PLCEXP C = 2;
PLCEXP D = 3;
PLCEXP E = 1004;
int main()
{
    // 写逻辑运算的表达式
    !(A+B * !D+C * !D) >> E;
    return 0;
}
```

##### 生成的代码

```haskell
LDNOT 0
LDNOT 1
LD 3
ORLD
ANDLD
LDNOT 2
LD 3
ORLD
ANDLD
OUT 1004
```

##### 梯形图

![](2.PNG)

